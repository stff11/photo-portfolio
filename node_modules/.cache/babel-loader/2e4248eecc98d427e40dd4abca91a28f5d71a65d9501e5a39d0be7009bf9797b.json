{"ast":null,"code":"import _objectSpread from \"/Users/stefano.foffano/node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n// src/errors/IcebergError.ts\nvar IcebergError = class extends Error {\n  constructor(message, opts) {\n    var _opts$icebergType;\n    super(message);\n    this.name = \"IcebergError\";\n    this.status = opts.status;\n    this.icebergType = opts.icebergType;\n    this.icebergCode = opts.icebergCode;\n    this.details = opts.details;\n    this.isCommitStateUnknown = opts.icebergType === \"CommitStateUnknownException\" || [500, 502, 504].includes(opts.status) && ((_opts$icebergType = opts.icebergType) === null || _opts$icebergType === void 0 ? void 0 : _opts$icebergType.includes(\"CommitState\")) === true;\n  }\n  /**\n   * Returns true if the error is a 404 Not Found error.\n   */\n  isNotFound() {\n    return this.status === 404;\n  }\n  /**\n   * Returns true if the error is a 409 Conflict error.\n   */\n  isConflict() {\n    return this.status === 409;\n  }\n  /**\n   * Returns true if the error is a 419 Authentication Timeout error.\n   */\n  isAuthenticationTimeout() {\n    return this.status === 419;\n  }\n};\n\n// src/utils/url.ts\nfunction buildUrl(baseUrl, path, query) {\n  const url = new URL(path, baseUrl);\n  if (query) {\n    for (const [key, value] of Object.entries(query)) {\n      if (value !== void 0) {\n        url.searchParams.set(key, value);\n      }\n    }\n  }\n  return url.toString();\n}\n\n// src/http/createFetchClient.ts\nasync function buildAuthHeaders(auth) {\n  if (!auth || auth.type === \"none\") {\n    return {};\n  }\n  if (auth.type === \"bearer\") {\n    return {\n      Authorization: \"Bearer \".concat(auth.token)\n    };\n  }\n  if (auth.type === \"header\") {\n    return {\n      [auth.name]: auth.value\n    };\n  }\n  if (auth.type === \"custom\") {\n    return await auth.getHeaders();\n  }\n  return {};\n}\nfunction createFetchClient(options) {\n  var _options$fetchImpl;\n  const fetchFn = (_options$fetchImpl = options.fetchImpl) !== null && _options$fetchImpl !== void 0 ? _options$fetchImpl : globalThis.fetch;\n  return {\n    async request(_ref) {\n      let {\n        method,\n        path,\n        query,\n        body,\n        headers\n      } = _ref;\n      const url = buildUrl(options.baseUrl, path, query);\n      const authHeaders = await buildAuthHeaders(options.auth);\n      const res = await fetchFn(url, {\n        method,\n        headers: _objectSpread(_objectSpread(_objectSpread({}, body ? {\n          \"Content-Type\": \"application/json\"\n        } : {}), authHeaders), headers),\n        body: body ? JSON.stringify(body) : void 0\n      });\n      const text = await res.text();\n      const isJson = (res.headers.get(\"content-type\") || \"\").includes(\"application/json\");\n      const data = isJson && text ? JSON.parse(text) : text;\n      if (!res.ok) {\n        var _errorDetail$message;\n        const errBody = isJson ? data : void 0;\n        const errorDetail = errBody === null || errBody === void 0 ? void 0 : errBody.error;\n        throw new IcebergError((_errorDetail$message = errorDetail === null || errorDetail === void 0 ? void 0 : errorDetail.message) !== null && _errorDetail$message !== void 0 ? _errorDetail$message : \"Request failed with status \".concat(res.status), {\n          status: res.status,\n          icebergType: errorDetail === null || errorDetail === void 0 ? void 0 : errorDetail.type,\n          icebergCode: errorDetail === null || errorDetail === void 0 ? void 0 : errorDetail.code,\n          details: errBody\n        });\n      }\n      return {\n        status: res.status,\n        headers: res.headers,\n        data\n      };\n    }\n  };\n}\n\n// src/catalog/namespaces.ts\nfunction namespaceToPath(namespace) {\n  return namespace.join(\"\u001f\");\n}\nvar NamespaceOperations = class {\n  constructor(client) {\n    let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    this.client = client;\n    this.prefix = prefix;\n  }\n  async listNamespaces(parent) {\n    const query = parent ? {\n      parent: namespaceToPath(parent.namespace)\n    } : void 0;\n    const response = await this.client.request({\n      method: \"GET\",\n      path: \"\".concat(this.prefix, \"/namespaces\"),\n      query\n    });\n    return response.data.namespaces.map(ns => ({\n      namespace: ns\n    }));\n  }\n  async createNamespace(id, metadata) {\n    const request = {\n      namespace: id.namespace,\n      properties: metadata === null || metadata === void 0 ? void 0 : metadata.properties\n    };\n    const response = await this.client.request({\n      method: \"POST\",\n      path: \"\".concat(this.prefix, \"/namespaces\"),\n      body: request\n    });\n    return response.data;\n  }\n  async dropNamespace(id) {\n    await this.client.request({\n      method: \"DELETE\",\n      path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath(id.namespace))\n    });\n  }\n  async loadNamespaceMetadata(id) {\n    const response = await this.client.request({\n      method: \"GET\",\n      path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath(id.namespace))\n    });\n    return {\n      properties: response.data.properties\n    };\n  }\n  async namespaceExists(id) {\n    try {\n      await this.client.request({\n        method: \"HEAD\",\n        path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath(id.namespace))\n      });\n      return true;\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 404) {\n        return false;\n      }\n      throw error;\n    }\n  }\n  async createNamespaceIfNotExists(id, metadata) {\n    try {\n      return await this.createNamespace(id, metadata);\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 409) {\n        return;\n      }\n      throw error;\n    }\n  }\n};\n\n// src/catalog/tables.ts\nfunction namespaceToPath2(namespace) {\n  return namespace.join(\"\u001f\");\n}\nvar TableOperations = class {\n  constructor(client) {\n    let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let accessDelegation = arguments.length > 2 ? arguments[2] : undefined;\n    this.client = client;\n    this.prefix = prefix;\n    this.accessDelegation = accessDelegation;\n  }\n  async listTables(namespace) {\n    const response = await this.client.request({\n      method: \"GET\",\n      path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath2(namespace.namespace), \"/tables\")\n    });\n    return response.data.identifiers;\n  }\n  async createTable(namespace, request) {\n    const headers = {};\n    if (this.accessDelegation) {\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n    }\n    const response = await this.client.request({\n      method: \"POST\",\n      path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath2(namespace.namespace), \"/tables\"),\n      body: request,\n      headers\n    });\n    return response.data.metadata;\n  }\n  async updateTable(id, request) {\n    const response = await this.client.request({\n      method: \"POST\",\n      path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath2(id.namespace), \"/tables/\").concat(id.name),\n      body: request\n    });\n    return {\n      \"metadata-location\": response.data[\"metadata-location\"],\n      metadata: response.data.metadata\n    };\n  }\n  async dropTable(id, options) {\n    var _options$purge;\n    await this.client.request({\n      method: \"DELETE\",\n      path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath2(id.namespace), \"/tables/\").concat(id.name),\n      query: {\n        purgeRequested: String((_options$purge = options === null || options === void 0 ? void 0 : options.purge) !== null && _options$purge !== void 0 ? _options$purge : false)\n      }\n    });\n  }\n  async loadTable(id) {\n    const headers = {};\n    if (this.accessDelegation) {\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n    }\n    const response = await this.client.request({\n      method: \"GET\",\n      path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath2(id.namespace), \"/tables/\").concat(id.name),\n      headers\n    });\n    return response.data.metadata;\n  }\n  async tableExists(id) {\n    const headers = {};\n    if (this.accessDelegation) {\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n    }\n    try {\n      await this.client.request({\n        method: \"HEAD\",\n        path: \"\".concat(this.prefix, \"/namespaces/\").concat(namespaceToPath2(id.namespace), \"/tables/\").concat(id.name),\n        headers\n      });\n      return true;\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 404) {\n        return false;\n      }\n      throw error;\n    }\n  }\n  async createTableIfNotExists(namespace, request) {\n    try {\n      return await this.createTable(namespace, request);\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 409) {\n        return await this.loadTable({\n          namespace: namespace.namespace,\n          name: request.name\n        });\n      }\n      throw error;\n    }\n  }\n};\n\n// src/catalog/IcebergRestCatalog.ts\nvar IcebergRestCatalog = class {\n  /**\n   * Creates a new Iceberg REST Catalog client.\n   *\n   * @param options - Configuration options for the catalog client\n   */\n  constructor(options) {\n    var _options$accessDelega;\n    let prefix = \"v1\";\n    if (options.catalogName) {\n      prefix += \"/\".concat(options.catalogName);\n    }\n    const baseUrl = options.baseUrl.endsWith(\"/\") ? options.baseUrl : \"\".concat(options.baseUrl, \"/\");\n    this.client = createFetchClient({\n      baseUrl,\n      auth: options.auth,\n      fetchImpl: options.fetch\n    });\n    this.accessDelegation = (_options$accessDelega = options.accessDelegation) === null || _options$accessDelega === void 0 ? void 0 : _options$accessDelega.join(\",\");\n    this.namespaceOps = new NamespaceOperations(this.client, prefix);\n    this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);\n  }\n  /**\n   * Lists all namespaces in the catalog.\n   *\n   * @param parent - Optional parent namespace to list children under\n   * @returns Array of namespace identifiers\n   *\n   * @example\n   * ```typescript\n   * // List all top-level namespaces\n   * const namespaces = await catalog.listNamespaces();\n   *\n   * // List namespaces under a parent\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\n   * ```\n   */\n  async listNamespaces(parent) {\n    return this.namespaceOps.listNamespaces(parent);\n  }\n  /**\n   * Creates a new namespace in the catalog.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespace(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * console.log(response.namespace); // ['analytics']\n   * console.log(response.properties); // { owner: 'data-team', ... }\n   * ```\n   */\n  async createNamespace(id, metadata) {\n    return this.namespaceOps.createNamespace(id, metadata);\n  }\n  /**\n   * Drops a namespace from the catalog.\n   *\n   * The namespace must be empty (contain no tables) before it can be dropped.\n   *\n   * @param id - Namespace identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\n   * ```\n   */\n  async dropNamespace(id) {\n    await this.namespaceOps.dropNamespace(id);\n  }\n  /**\n   * Loads metadata for a namespace.\n   *\n   * @param id - Namespace identifier to load\n   * @returns Namespace metadata including properties\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\n   * console.log(metadata.properties);\n   * ```\n   */\n  async loadNamespaceMetadata(id) {\n    return this.namespaceOps.loadNamespaceMetadata(id);\n  }\n  /**\n   * Lists all tables in a namespace.\n   *\n   * @param namespace - Namespace identifier to list tables from\n   * @returns Array of table identifiers\n   *\n   * @example\n   * ```typescript\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\n   * ```\n   */\n  async listTables(namespace) {\n    return this.tableOps.listTables(namespace);\n  }\n  /**\n   * Creates a new table in the catalog.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTable(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: [\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\n   *       ]\n   *     }\n   *   }\n   * );\n   * ```\n   */\n  async createTable(namespace, request) {\n    return this.tableOps.createTable(namespace, request);\n  }\n  /**\n   * Updates an existing table's metadata.\n   *\n   * Can update the schema, partition spec, or properties of a table.\n   *\n   * @param id - Table identifier to update\n   * @param request - Update request with fields to modify\n   * @returns Response containing the metadata location and updated table metadata\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.updateTable(\n   *   { namespace: ['analytics'], name: 'events' },\n   *   {\n   *     properties: { 'read.split.target-size': '134217728' }\n   *   }\n   * );\n   * console.log(response['metadata-location']); // s3://...\n   * console.log(response.metadata); // TableMetadata object\n   * ```\n   */\n  async updateTable(id, request) {\n    return this.tableOps.updateTable(id, request);\n  }\n  /**\n   * Drops a table from the catalog.\n   *\n   * @param id - Table identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\n   * ```\n   */\n  async dropTable(id, options) {\n    await this.tableOps.dropTable(id, options);\n  }\n  /**\n   * Loads metadata for a table.\n   *\n   * @param id - Table identifier to load\n   * @returns Table metadata including schema, partition spec, location, etc.\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\n   * console.log(metadata.schema);\n   * console.log(metadata.location);\n   * ```\n   */\n  async loadTable(id) {\n    return this.tableOps.loadTable(id);\n  }\n  /**\n   * Checks if a namespace exists in the catalog.\n   *\n   * @param id - Namespace identifier to check\n   * @returns True if the namespace exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\n   * console.log(exists); // true or false\n   * ```\n   */\n  async namespaceExists(id) {\n    return this.namespaceOps.namespaceExists(id);\n  }\n  /**\n   * Checks if a table exists in the catalog.\n   *\n   * @param id - Table identifier to check\n   * @returns True if the table exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\n   * console.log(exists); // true or false\n   * ```\n   */\n  async tableExists(id) {\n    return this.tableOps.tableExists(id);\n  }\n  /**\n   * Creates a namespace if it does not exist.\n   *\n   * If the namespace already exists, returns void. If created, returns the response.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties, or void if it already exists\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespaceIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * if (response) {\n   *   console.log('Created:', response.namespace);\n   * } else {\n   *   console.log('Already exists');\n   * }\n   * ```\n   */\n  async createNamespaceIfNotExists(id, metadata) {\n    return this.namespaceOps.createNamespaceIfNotExists(id, metadata);\n  }\n  /**\n   * Creates a table if it does not exist.\n   *\n   * If the table already exists, returns its metadata instead.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created or existing table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTableIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     }\n   *   }\n   * );\n   * ```\n   */\n  async createTableIfNotExists(namespace, request) {\n    return this.tableOps.createTableIfNotExists(namespace, request);\n  }\n};\n\n// src/catalog/types.ts\nvar DECIMAL_REGEX = /^decimal\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/;\nvar FIXED_REGEX = /^fixed\\s*\\[\\s*(\\d+)\\s*\\]$/;\nfunction parseDecimalType(type) {\n  const match = type.match(DECIMAL_REGEX);\n  if (!match) return null;\n  return {\n    precision: parseInt(match[1], 10),\n    scale: parseInt(match[2], 10)\n  };\n}\nfunction parseFixedType(type) {\n  const match = type.match(FIXED_REGEX);\n  if (!match) return null;\n  return {\n    length: parseInt(match[1], 10)\n  };\n}\nfunction isDecimalType(type) {\n  return DECIMAL_REGEX.test(type);\n}\nfunction isFixedType(type) {\n  return FIXED_REGEX.test(type);\n}\nfunction typesEqual(a, b) {\n  const decimalA = parseDecimalType(a);\n  const decimalB = parseDecimalType(b);\n  if (decimalA && decimalB) {\n    return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale;\n  }\n  const fixedA = parseFixedType(a);\n  const fixedB = parseFixedType(b);\n  if (fixedA && fixedB) {\n    return fixedA.length === fixedB.length;\n  }\n  return a === b;\n}\nfunction getCurrentSchema(metadata) {\n  return metadata.schemas.find(s => s[\"schema-id\"] === metadata[\"current-schema-id\"]);\n}\nexport { IcebergError, IcebergRestCatalog, getCurrentSchema, isDecimalType, isFixedType, parseDecimalType, parseFixedType, typesEqual };\n\n//# sourceMappingURL=index.mjs.map","map":{"version":3,"names":["IcebergError","Error","constructor","message","opts","_opts$icebergType","name","status","icebergType","icebergCode","details","isCommitStateUnknown","includes","isNotFound","isConflict","isAuthenticationTimeout","buildUrl","baseUrl","path","query","url","URL","key","value","Object","entries","searchParams","set","toString","buildAuthHeaders","auth","type","Authorization","concat","token","getHeaders","createFetchClient","options","_options$fetchImpl","fetchFn","fetchImpl","globalThis","fetch","request","_ref","method","body","headers","authHeaders","res","_objectSpread","JSON","stringify","text","isJson","get","data","parse","ok","_errorDetail$message","errBody","errorDetail","error","code","namespaceToPath","namespace","join","NamespaceOperations","client","prefix","arguments","length","undefined","listNamespaces","parent","response","namespaces","map","ns","createNamespace","id","metadata","properties","dropNamespace","loadNamespaceMetadata","namespaceExists","createNamespaceIfNotExists","namespaceToPath2","TableOperations","accessDelegation","listTables","identifiers","createTable","updateTable","dropTable","_options$purge","purgeRequested","String","purge","loadTable","tableExists","createTableIfNotExists","IcebergRestCatalog","_options$accessDelega","catalogName","endsWith","namespaceOps","tableOps","DECIMAL_REGEX","FIXED_REGEX","parseDecimalType","match","precision","parseInt","scale","parseFixedType","isDecimalType","test","isFixedType","typesEqual","a","b","decimalA","decimalB","fixedA","fixedB","getCurrentSchema","schemas","find","s"],"sources":["/Users/stefano.foffano/Desktop/photo-portfolio claude/node_modules/iceberg-js/src/errors/IcebergError.ts","/Users/stefano.foffano/Desktop/photo-portfolio claude/node_modules/iceberg-js/src/utils/url.ts","/Users/stefano.foffano/Desktop/photo-portfolio claude/node_modules/iceberg-js/src/http/createFetchClient.ts","/Users/stefano.foffano/Desktop/photo-portfolio claude/node_modules/iceberg-js/src/catalog/namespaces.ts","/Users/stefano.foffano/Desktop/photo-portfolio claude/node_modules/iceberg-js/src/catalog/tables.ts","/Users/stefano.foffano/Desktop/photo-portfolio claude/node_modules/iceberg-js/src/catalog/IcebergRestCatalog.ts","/Users/stefano.foffano/Desktop/photo-portfolio claude/node_modules/iceberg-js/src/catalog/types.ts"],"sourcesContent":["export interface IcebergErrorResponse {\n  error: {\n    message: string\n    type: string\n    code: number\n    stack?: string[]\n  }\n}\n\nexport class IcebergError extends Error {\n  readonly status: number\n  readonly icebergType?: string\n  readonly icebergCode?: number\n  readonly details?: unknown\n  readonly isCommitStateUnknown: boolean\n\n  constructor(\n    message: string,\n    opts: {\n      status: number\n      icebergType?: string\n      icebergCode?: number\n      details?: unknown\n    }\n  ) {\n    super(message)\n    this.name = 'IcebergError'\n    this.status = opts.status\n    this.icebergType = opts.icebergType\n    this.icebergCode = opts.icebergCode\n    this.details = opts.details\n\n    // Detect CommitStateUnknownException (500, 502, 504 during table commits)\n    this.isCommitStateUnknown =\n      opts.icebergType === 'CommitStateUnknownException' ||\n      ([500, 502, 504].includes(opts.status) && opts.icebergType?.includes('CommitState') === true)\n  }\n\n  /**\n   * Returns true if the error is a 404 Not Found error.\n   */\n  isNotFound(): boolean {\n    return this.status === 404\n  }\n\n  /**\n   * Returns true if the error is a 409 Conflict error.\n   */\n  isConflict(): boolean {\n    return this.status === 409\n  }\n\n  /**\n   * Returns true if the error is a 419 Authentication Timeout error.\n   */\n  isAuthenticationTimeout(): boolean {\n    return this.status === 419\n  }\n}\n","export function buildUrl(\n  baseUrl: string,\n  path: string,\n  query?: Record<string, string | undefined>\n): string {\n  const url = new URL(path, baseUrl)\n\n  if (query) {\n    for (const [key, value] of Object.entries(query)) {\n      if (value !== undefined) {\n        url.searchParams.set(key, value)\n      }\n    }\n  }\n\n  return url.toString()\n}\n","import { IcebergError, type IcebergErrorResponse } from '../errors/IcebergError'\nimport { buildUrl } from '../utils/url'\nimport type { AuthConfig, HttpClient, HttpRequest, HttpResponse } from './types'\n\nasync function buildAuthHeaders(auth?: AuthConfig): Promise<Record<string, string>> {\n  if (!auth || auth.type === 'none') {\n    return {}\n  }\n\n  if (auth.type === 'bearer') {\n    return { Authorization: `Bearer ${auth.token}` }\n  }\n\n  if (auth.type === 'header') {\n    return { [auth.name]: auth.value }\n  }\n\n  if (auth.type === 'custom') {\n    return await auth.getHeaders()\n  }\n\n  return {}\n}\n\nexport function createFetchClient(options: {\n  baseUrl: string\n  auth?: AuthConfig\n  fetchImpl?: typeof fetch\n}): HttpClient {\n  const fetchFn = options.fetchImpl ?? globalThis.fetch\n\n  return {\n    async request<T>({\n      method,\n      path,\n      query,\n      body,\n      headers,\n    }: HttpRequest): Promise<HttpResponse<T>> {\n      const url = buildUrl(options.baseUrl, path, query)\n      const authHeaders = await buildAuthHeaders(options.auth)\n\n      const res = await fetchFn(url, {\n        method,\n        headers: {\n          ...(body ? { 'Content-Type': 'application/json' } : {}),\n          ...authHeaders,\n          ...headers,\n        },\n        body: body ? JSON.stringify(body) : undefined,\n      })\n\n      const text = await res.text()\n      const isJson = (res.headers.get('content-type') || '').includes('application/json')\n      const data = isJson && text ? (JSON.parse(text) as T) : (text as T)\n\n      if (!res.ok) {\n        const errBody = isJson ? (data as IcebergErrorResponse) : undefined\n        const errorDetail = errBody?.error\n        throw new IcebergError(\n          errorDetail?.message ?? `Request failed with status ${res.status}`,\n          {\n            status: res.status,\n            icebergType: errorDetail?.type,\n            icebergCode: errorDetail?.code,\n            details: errBody,\n          }\n        )\n      }\n\n      return { status: res.status, headers: res.headers, data: data as T }\n    },\n  }\n}\n","import type { HttpClient } from '../http/types'\nimport { IcebergError } from '../errors/IcebergError'\nimport type {\n  CreateNamespaceRequest,\n  CreateNamespaceResponse,\n  GetNamespaceResponse,\n  ListNamespacesResponse,\n  NamespaceIdentifier,\n  NamespaceMetadata,\n} from './types'\n\nfunction namespaceToPath(namespace: string[]): string {\n  return namespace.join('\\x1F')\n}\n\nexport class NamespaceOperations {\n  constructor(\n    private readonly client: HttpClient,\n    private readonly prefix: string = ''\n  ) {}\n\n  async listNamespaces(parent?: NamespaceIdentifier): Promise<NamespaceIdentifier[]> {\n    const query = parent ? { parent: namespaceToPath(parent.namespace) } : undefined\n\n    const response = await this.client.request<ListNamespacesResponse>({\n      method: 'GET',\n      path: `${this.prefix}/namespaces`,\n      query,\n    })\n\n    return response.data.namespaces.map((ns) => ({ namespace: ns }))\n  }\n\n  async createNamespace(\n    id: NamespaceIdentifier,\n    metadata?: NamespaceMetadata\n  ): Promise<CreateNamespaceResponse> {\n    const request: CreateNamespaceRequest = {\n      namespace: id.namespace,\n      properties: metadata?.properties,\n    }\n\n    const response = await this.client.request<CreateNamespaceResponse>({\n      method: 'POST',\n      path: `${this.prefix}/namespaces`,\n      body: request,\n    })\n\n    return response.data\n  }\n\n  async dropNamespace(id: NamespaceIdentifier): Promise<void> {\n    await this.client.request<void>({\n      method: 'DELETE',\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`,\n    })\n  }\n\n  async loadNamespaceMetadata(id: NamespaceIdentifier): Promise<NamespaceMetadata> {\n    const response = await this.client.request<GetNamespaceResponse>({\n      method: 'GET',\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`,\n    })\n\n    return {\n      properties: response.data.properties,\n    }\n  }\n\n  async namespaceExists(id: NamespaceIdentifier): Promise<boolean> {\n    try {\n      await this.client.request<void>({\n        method: 'HEAD',\n        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`,\n      })\n      return true\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 404) {\n        return false\n      }\n      throw error\n    }\n  }\n\n  async createNamespaceIfNotExists(\n    id: NamespaceIdentifier,\n    metadata?: NamespaceMetadata\n  ): Promise<CreateNamespaceResponse | void> {\n    try {\n      return await this.createNamespace(id, metadata)\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 409) {\n        return\n      }\n      throw error\n    }\n  }\n}\n","import type { HttpClient } from '../http/types'\nimport { IcebergError } from '../errors/IcebergError'\nimport type {\n  CreateTableRequest,\n  CommitTableResponse,\n  ListTablesResponse,\n  LoadTableResponse,\n  NamespaceIdentifier,\n  TableIdentifier,\n  TableMetadata,\n  UpdateTableRequest,\n  DropTableRequest,\n} from './types'\n\nfunction namespaceToPath(namespace: string[]): string {\n  return namespace.join('\\x1F')\n}\n\nexport class TableOperations {\n  constructor(\n    private readonly client: HttpClient,\n    private readonly prefix: string = '',\n    private readonly accessDelegation?: string\n  ) {}\n\n  async listTables(namespace: NamespaceIdentifier): Promise<TableIdentifier[]> {\n    const response = await this.client.request<ListTablesResponse>({\n      method: 'GET',\n      path: `${this.prefix}/namespaces/${namespaceToPath(namespace.namespace)}/tables`,\n    })\n\n    return response.data.identifiers\n  }\n\n  async createTable(\n    namespace: NamespaceIdentifier,\n    request: CreateTableRequest\n  ): Promise<TableMetadata> {\n    const headers: Record<string, string> = {}\n    if (this.accessDelegation) {\n      headers['X-Iceberg-Access-Delegation'] = this.accessDelegation\n    }\n\n    const response = await this.client.request<LoadTableResponse>({\n      method: 'POST',\n      path: `${this.prefix}/namespaces/${namespaceToPath(namespace.namespace)}/tables`,\n      body: request,\n      headers,\n    })\n\n    return response.data.metadata\n  }\n\n  async updateTable(id: TableIdentifier, request: UpdateTableRequest): Promise<CommitTableResponse> {\n    const response = await this.client.request<LoadTableResponse>({\n      method: 'POST',\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}/tables/${id.name}`,\n      body: request,\n    })\n\n    return {\n      'metadata-location': response.data['metadata-location'],\n      metadata: response.data.metadata,\n    }\n  }\n\n  async dropTable(id: TableIdentifier, options?: DropTableRequest): Promise<void> {\n    await this.client.request<void>({\n      method: 'DELETE',\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}/tables/${id.name}`,\n      query: { purgeRequested: String(options?.purge ?? false) },\n    })\n  }\n\n  async loadTable(id: TableIdentifier): Promise<TableMetadata> {\n    const headers: Record<string, string> = {}\n    if (this.accessDelegation) {\n      headers['X-Iceberg-Access-Delegation'] = this.accessDelegation\n    }\n\n    const response = await this.client.request<LoadTableResponse>({\n      method: 'GET',\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}/tables/${id.name}`,\n      headers,\n    })\n\n    return response.data.metadata\n  }\n\n  async tableExists(id: TableIdentifier): Promise<boolean> {\n    const headers: Record<string, string> = {}\n    if (this.accessDelegation) {\n      headers['X-Iceberg-Access-Delegation'] = this.accessDelegation\n    }\n\n    try {\n      await this.client.request<void>({\n        method: 'HEAD',\n        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}/tables/${id.name}`,\n        headers,\n      })\n      return true\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 404) {\n        return false\n      }\n      throw error\n    }\n  }\n\n  async createTableIfNotExists(\n    namespace: NamespaceIdentifier,\n    request: CreateTableRequest\n  ): Promise<TableMetadata> {\n    try {\n      return await this.createTable(namespace, request)\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 409) {\n        return await this.loadTable({ namespace: namespace.namespace, name: request.name })\n      }\n      throw error\n    }\n  }\n}\n","import { createFetchClient } from '../http/createFetchClient'\nimport type { AuthConfig, HttpClient } from '../http/types'\nimport { NamespaceOperations } from './namespaces'\nimport { TableOperations } from './tables'\nimport type {\n  CreateTableRequest,\n  CreateNamespaceResponse,\n  CommitTableResponse,\n  NamespaceIdentifier,\n  NamespaceMetadata,\n  TableIdentifier,\n  TableMetadata,\n  UpdateTableRequest,\n  DropTableRequest,\n} from './types'\n\n/**\n * Access delegation mechanisms supported by the Iceberg REST Catalog.\n *\n * - `vended-credentials`: Server provides temporary credentials for data access\n * - `remote-signing`: Server signs requests on behalf of the client\n */\nexport type AccessDelegation = 'vended-credentials' | 'remote-signing'\n\n/**\n * Configuration options for the Iceberg REST Catalog client.\n */\nexport interface IcebergRestCatalogOptions {\n  /** Base URL of the Iceberg REST Catalog API */\n  baseUrl: string\n  /** Optional catalog name prefix for multi-catalog servers */\n  catalogName?: string\n  /** Authentication configuration */\n  auth?: AuthConfig\n  /** Custom fetch implementation (defaults to globalThis.fetch) */\n  fetch?: typeof fetch\n  /**\n   * Access delegation mechanisms to request from the server.\n   * When specified, the X-Iceberg-Access-Delegation header will be sent\n   * with supported operations (createTable, loadTable).\n   *\n   * @example ['vended-credentials']\n   * @example ['vended-credentials', 'remote-signing']\n   */\n  accessDelegation?: AccessDelegation[]\n}\n\n/**\n * Client for interacting with an Apache Iceberg REST Catalog.\n *\n * This class provides methods for managing namespaces and tables in an Iceberg catalog.\n * It handles authentication, request formatting, and error handling automatically.\n *\n * @example\n * ```typescript\n * const catalog = new IcebergRestCatalog({\n *   baseUrl: 'https://my-catalog.example.com/iceberg/v1',\n *   auth: { type: 'bearer', token: process.env.ICEBERG_TOKEN }\n * });\n *\n * // Create a namespace\n * await catalog.createNamespace({ namespace: ['analytics'] });\n *\n * // Create a table\n * await catalog.createTable(\n *   { namespace: ['analytics'] },\n *   {\n *     name: 'events',\n *     schema: { type: 'struct', fields: [...] }\n *   }\n * );\n * ```\n */\nexport class IcebergRestCatalog {\n  private readonly client: HttpClient\n  private readonly namespaceOps: NamespaceOperations\n  private readonly tableOps: TableOperations\n  private readonly accessDelegation?: string\n\n  /**\n   * Creates a new Iceberg REST Catalog client.\n   *\n   * @param options - Configuration options for the catalog client\n   */\n  constructor(options: IcebergRestCatalogOptions) {\n    let prefix = 'v1'\n    if (options.catalogName) {\n      prefix += `/${options.catalogName}`\n    }\n\n    const baseUrl = options.baseUrl.endsWith('/') ? options.baseUrl : `${options.baseUrl}/`\n\n    this.client = createFetchClient({\n      baseUrl,\n      auth: options.auth,\n      fetchImpl: options.fetch,\n    })\n\n    // Format accessDelegation as comma-separated string per spec\n    this.accessDelegation = options.accessDelegation?.join(',')\n\n    this.namespaceOps = new NamespaceOperations(this.client, prefix)\n    this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation)\n  }\n\n  /**\n   * Lists all namespaces in the catalog.\n   *\n   * @param parent - Optional parent namespace to list children under\n   * @returns Array of namespace identifiers\n   *\n   * @example\n   * ```typescript\n   * // List all top-level namespaces\n   * const namespaces = await catalog.listNamespaces();\n   *\n   * // List namespaces under a parent\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\n   * ```\n   */\n  async listNamespaces(parent?: NamespaceIdentifier): Promise<NamespaceIdentifier[]> {\n    return this.namespaceOps.listNamespaces(parent)\n  }\n\n  /**\n   * Creates a new namespace in the catalog.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespace(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * console.log(response.namespace); // ['analytics']\n   * console.log(response.properties); // { owner: 'data-team', ... }\n   * ```\n   */\n  async createNamespace(id: NamespaceIdentifier, metadata?: NamespaceMetadata): Promise<CreateNamespaceResponse> {\n    return this.namespaceOps.createNamespace(id, metadata)\n  }\n\n  /**\n   * Drops a namespace from the catalog.\n   *\n   * The namespace must be empty (contain no tables) before it can be dropped.\n   *\n   * @param id - Namespace identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\n   * ```\n   */\n  async dropNamespace(id: NamespaceIdentifier): Promise<void> {\n    await this.namespaceOps.dropNamespace(id)\n  }\n\n  /**\n   * Loads metadata for a namespace.\n   *\n   * @param id - Namespace identifier to load\n   * @returns Namespace metadata including properties\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\n   * console.log(metadata.properties);\n   * ```\n   */\n  async loadNamespaceMetadata(id: NamespaceIdentifier): Promise<NamespaceMetadata> {\n    return this.namespaceOps.loadNamespaceMetadata(id)\n  }\n\n  /**\n   * Lists all tables in a namespace.\n   *\n   * @param namespace - Namespace identifier to list tables from\n   * @returns Array of table identifiers\n   *\n   * @example\n   * ```typescript\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\n   * ```\n   */\n  async listTables(namespace: NamespaceIdentifier): Promise<TableIdentifier[]> {\n    return this.tableOps.listTables(namespace)\n  }\n\n  /**\n   * Creates a new table in the catalog.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTable(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: [\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\n   *       ]\n   *     }\n   *   }\n   * );\n   * ```\n   */\n  async createTable(\n    namespace: NamespaceIdentifier,\n    request: CreateTableRequest\n  ): Promise<TableMetadata> {\n    return this.tableOps.createTable(namespace, request)\n  }\n\n  /**\n   * Updates an existing table's metadata.\n   *\n   * Can update the schema, partition spec, or properties of a table.\n   *\n   * @param id - Table identifier to update\n   * @param request - Update request with fields to modify\n   * @returns Response containing the metadata location and updated table metadata\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.updateTable(\n   *   { namespace: ['analytics'], name: 'events' },\n   *   {\n   *     properties: { 'read.split.target-size': '134217728' }\n   *   }\n   * );\n   * console.log(response['metadata-location']); // s3://...\n   * console.log(response.metadata); // TableMetadata object\n   * ```\n   */\n  async updateTable(id: TableIdentifier, request: UpdateTableRequest): Promise<CommitTableResponse> {\n    return this.tableOps.updateTable(id, request)\n  }\n\n  /**\n   * Drops a table from the catalog.\n   *\n   * @param id - Table identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\n   * ```\n   */\n  async dropTable(id: TableIdentifier, options?: DropTableRequest): Promise<void> {\n    await this.tableOps.dropTable(id, options)\n  }\n\n  /**\n   * Loads metadata for a table.\n   *\n   * @param id - Table identifier to load\n   * @returns Table metadata including schema, partition spec, location, etc.\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\n   * console.log(metadata.schema);\n   * console.log(metadata.location);\n   * ```\n   */\n  async loadTable(id: TableIdentifier): Promise<TableMetadata> {\n    return this.tableOps.loadTable(id)\n  }\n\n  /**\n   * Checks if a namespace exists in the catalog.\n   *\n   * @param id - Namespace identifier to check\n   * @returns True if the namespace exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\n   * console.log(exists); // true or false\n   * ```\n   */\n  async namespaceExists(id: NamespaceIdentifier): Promise<boolean> {\n    return this.namespaceOps.namespaceExists(id)\n  }\n\n  /**\n   * Checks if a table exists in the catalog.\n   *\n   * @param id - Table identifier to check\n   * @returns True if the table exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\n   * console.log(exists); // true or false\n   * ```\n   */\n  async tableExists(id: TableIdentifier): Promise<boolean> {\n    return this.tableOps.tableExists(id)\n  }\n\n  /**\n   * Creates a namespace if it does not exist.\n   *\n   * If the namespace already exists, returns void. If created, returns the response.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties, or void if it already exists\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespaceIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * if (response) {\n   *   console.log('Created:', response.namespace);\n   * } else {\n   *   console.log('Already exists');\n   * }\n   * ```\n   */\n  async createNamespaceIfNotExists(\n    id: NamespaceIdentifier,\n    metadata?: NamespaceMetadata\n  ): Promise<CreateNamespaceResponse | void> {\n    return this.namespaceOps.createNamespaceIfNotExists(id, metadata)\n  }\n\n  /**\n   * Creates a table if it does not exist.\n   *\n   * If the table already exists, returns its metadata instead.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created or existing table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTableIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     }\n   *   }\n   * );\n   * ```\n   */\n  async createTableIfNotExists(\n    namespace: NamespaceIdentifier,\n    request: CreateTableRequest\n  ): Promise<TableMetadata> {\n    return this.tableOps.createTableIfNotExists(namespace, request)\n  }\n}\n","export interface NamespaceIdentifier {\n  namespace: string[]\n}\n\nexport interface NamespaceMetadata {\n  properties: Record<string, string>\n}\n\nexport interface TableIdentifier {\n  namespace: string[]\n  name: string\n}\n\n/**\n * Primitive types in Iceberg - all represented as strings.\n * Parameterized types use string format: decimal(precision,scale) and fixed[length]\n *\n * Note: The OpenAPI spec defines PrimitiveType as `type: string`, so any string is valid.\n * We include known types for autocomplete, plus a catch-all for flexibility.\n */\nexport type PrimitiveType =\n  | 'boolean'\n  | 'int'\n  | 'long'\n  | 'float'\n  | 'double'\n  | 'string'\n  | 'timestamp'\n  | 'date'\n  | 'time'\n  | 'timestamptz'\n  | 'uuid'\n  | 'binary'\n  | `decimal(${number},${number})`\n  | `fixed[${number}]`\n  | (string & {}) // catch-all for any format (e.g., \"decimal(10, 2)\" with spaces) and future types\n\n/**\n * Regex patterns for parsing parameterized types.\n * These allow flexible whitespace matching.\n */\nconst DECIMAL_REGEX = /^decimal\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/\nconst FIXED_REGEX = /^fixed\\s*\\[\\s*(\\d+)\\s*\\]$/\n\n/**\n * Parse a decimal type string into its components.\n * Handles any whitespace formatting (e.g., \"decimal(10,2)\", \"decimal(10, 2)\", \"decimal( 10 , 2 )\").\n *\n * @param type - The type string to parse\n * @returns Object with precision and scale, or null if not a valid decimal type\n */\nexport function parseDecimalType(type: string): { precision: number; scale: number } | null {\n  const match = type.match(DECIMAL_REGEX)\n  if (!match) return null\n  return {\n    precision: parseInt(match[1], 10),\n    scale: parseInt(match[2], 10),\n  }\n}\n\n/**\n * Parse a fixed type string into its length.\n * Handles any whitespace formatting (e.g., \"fixed[16]\", \"fixed[ 16 ]\").\n *\n * @param type - The type string to parse\n * @returns Object with length, or null if not a valid fixed type\n */\nexport function parseFixedType(type: string): { length: number } | null {\n  const match = type.match(FIXED_REGEX)\n  if (!match) return null\n  return {\n    length: parseInt(match[1], 10),\n  }\n}\n\n/**\n * Check if a type string is a decimal type.\n */\nexport function isDecimalType(type: string): boolean {\n  return DECIMAL_REGEX.test(type)\n}\n\n/**\n * Check if a type string is a fixed type.\n */\nexport function isFixedType(type: string): boolean {\n  return FIXED_REGEX.test(type)\n}\n\n/**\n * Compare two Iceberg type strings for equality, ignoring whitespace differences.\n * This is useful when comparing types from user input vs catalog responses,\n * as catalogs may normalize whitespace differently.\n *\n * @param a - First type string\n * @param b - Second type string\n * @returns true if the types are equivalent\n */\nexport function typesEqual(a: string, b: string): boolean {\n  // For decimal types, compare parsed values\n  const decimalA = parseDecimalType(a)\n  const decimalB = parseDecimalType(b)\n  if (decimalA && decimalB) {\n    return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale\n  }\n\n  // For fixed types, compare parsed values\n  const fixedA = parseFixedType(a)\n  const fixedB = parseFixedType(b)\n  if (fixedA && fixedB) {\n    return fixedA.length === fixedB.length\n  }\n\n  // For other types, direct string comparison\n  return a === b\n}\n\n/**\n * Struct type - a nested structure containing fields.\n * Used for nested records within a field.\n */\nexport interface StructType {\n  type: 'struct'\n  fields: StructField[]\n}\n\n/**\n * List type - an array of elements.\n */\nexport interface ListType {\n  type: 'list'\n  'element-id': number\n  element: IcebergType\n  'element-required': boolean\n}\n\n/**\n * Map type - a key-value mapping.\n */\nexport interface MapType {\n  type: 'map'\n  'key-id': number\n  key: IcebergType\n  'value-id': number\n  value: IcebergType\n  'value-required': boolean\n}\n\n/**\n * Union of all Iceberg types.\n * Can be a primitive type (string) or a complex type (struct, list, map).\n */\nexport type IcebergType = PrimitiveType | StructType | ListType | MapType\n\n/**\n * Primitive type values for default values.\n * Represents the possible values for initial-default and write-default.\n */\nexport type PrimitiveTypeValue = boolean | number | string\n\n/**\n * A field within a struct (used in nested StructType).\n */\nexport interface StructField {\n  id: number\n  name: string\n  type: IcebergType\n  required: boolean\n  doc?: string\n  'initial-default'?: PrimitiveTypeValue\n  'write-default'?: PrimitiveTypeValue\n}\n\n/**\n * A field within a table schema (top-level).\n * Equivalent to StructField but kept for backwards compatibility.\n */\nexport interface TableField {\n  id: number\n  name: string\n  type: IcebergType\n  required: boolean\n  doc?: string\n  'initial-default'?: PrimitiveTypeValue\n  'write-default'?: PrimitiveTypeValue\n}\n\nexport interface TableSchema {\n  type: 'struct'\n  fields: TableField[]\n  'schema-id'?: number\n  'identifier-field-ids'?: number[]\n}\n\nexport interface PartitionField {\n  source_id: number\n  field_id: number\n  name: string\n  transform: string\n}\n\nexport interface PartitionSpec {\n  'spec-id': number\n  fields: PartitionField[]\n}\n\nexport interface SortField {\n  source_id: number\n  transform: string\n  direction: 'asc' | 'desc'\n  null_order: 'nulls-first' | 'nulls-last'\n}\n\nexport interface SortOrder {\n  'order-id': number\n  fields: SortField[]\n}\n\nexport interface CreateTableRequest {\n  name: string\n  schema: TableSchema\n  'partition-spec'?: PartitionSpec\n  'write-order'?: SortOrder\n  properties?: Record<string, string>\n  'stage-create'?: boolean\n}\n\nexport interface UpdateTableRequest {\n  schema?: TableSchema\n  'partition-spec'?: PartitionSpec\n  properties?: Record<string, string>\n}\n\nexport interface DropTableRequest {\n  purge?: boolean\n}\n\nexport interface TableMetadata {\n  name?: string\n  location: string\n  schemas: TableSchema[]\n  'current-schema-id': number\n  'partition-specs': PartitionSpec[]\n  'default-spec-id'?: number\n  'sort-orders': SortOrder[]\n  'default-sort-order-id'?: number\n  properties: Record<string, string>\n  'metadata-location'?: string\n  'current-snapshot-id'?: number\n  snapshots?: unknown[]\n  'snapshot-log'?: unknown[]\n  'metadata-log'?: unknown[]\n  refs?: Record<string, unknown>\n  'last-updated-ms'?: number\n  'last-column-id'?: number\n  'last-sequence-number'?: number\n  'table-uuid'?: string\n  'format-version'?: number\n  'last-partition-id'?: number\n}\n\nexport interface CreateNamespaceRequest {\n  namespace: string[]\n  properties?: Record<string, string>\n}\n\nexport interface CreateNamespaceResponse {\n  namespace: string[]\n  properties?: Record<string, string>\n}\n\nexport interface GetNamespaceResponse {\n  namespace: string[]\n  properties: Record<string, string>\n}\n\nexport interface ListNamespacesResponse {\n  namespaces: string[][]\n  'next-page-token'?: string\n}\n\nexport interface ListTablesResponse {\n  identifiers: TableIdentifier[]\n  'next-page-token'?: string\n}\n\nexport interface LoadTableResponse {\n  'metadata-location': string\n  metadata: TableMetadata\n  config?: Record<string, string>\n}\n\nexport interface CommitTableResponse {\n  'metadata-location': string\n  metadata: TableMetadata\n}\n\n/**\n * Gets the current (active) schema from table metadata.\n *\n * @param metadata - Table metadata containing schemas array and current-schema-id\n * @returns The current table schema, or undefined if not found\n */\nexport function getCurrentSchema(metadata: TableMetadata): TableSchema | undefined {\n  return metadata.schemas.find((s) => s['schema-id'] === metadata['current-schema-id'])\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}